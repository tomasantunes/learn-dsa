<!DOCTYPE html>
<html>
  <head>
    <title>Learn DSA</title>
    <link rel='stylesheet' href='/stylesheets/style.css' />
    <%- include('../../partials/head') %>
  </head>
  <body>

    <div class="d-flex">
      <%- include('../../partials/sidebar') %>

      <main class="flex-fill p-4">
        <div class="text-center">
          <h3>Heap Sort</h3>
        </div>
        
        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Heap Sort – Introduction

            Heap Sort is a **comparison-based sorting algorithm** based on the **binary heap** data structure.

            It works in two main phases:

            1. Build a heap from the input array
            2. Repeatedly extract the maximum element

            Properties:

            - In-place algorithm
            - Not stable
            - Deterministic performance

            ####Time = O(n log n)####

            mermaid
            graph TD;
              HeapSort --> BuildHeap;
              HeapSort --> ExtractMax;
              BuildHeap --> SortedArray;
              ExtractMax --> SortedArray;
            /mermaid
            </script>
          </div>
        </div>

        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Binary Heap Concept

            A **binary heap** is a **complete binary tree**.

            In a **Max Heap**:

            - Parent ≥ Children
            - Largest value is at the root

            Example heap:

            ####Parent ≥ Child####

            mermaid
            graph TD;
              50 --> 30;
              50 --> 40;
              30 --> 10;
              30 --> 20;
              40 --> 35;
              40 --> 25;
            /mermaid
            </script>
          </div>
        </div>

        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Array Representation of a Heap

            A heap is usually stored inside an array.

            For index ####i####:

            - Left child = ####2i + 1####
            - Right child = ####2i + 2####
            - Parent = ####floor((i-1)/2)####

            Example array:

            [50, 30, 40, 10, 20, 35, 25]

            mermaid
            graph TD;
              A0["0:50"] --> A1["1:30"];
              A0 --> A2["2:40"];
              A1 --> A3["3:10"];
              A1 --> A4["4:20"];
              A2 --> A5["5:35"];
              A2 --> A6["6:25"];
            /mermaid
            </script>
          </div>
        </div>

        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Step 1 – Build the Heap

            First we transform the array into a **Max Heap**.

            We start from the **last non-leaf node** and move upward.

            Heapify is applied to each node.

            ####Start = floor(n/2) - 1####

            mermaid
            graph TD;
              BuildHeap --> HeapifyNode3;
              BuildHeap --> HeapifyNode2;
              BuildHeap --> HeapifyNode1;
              BuildHeap --> HeapifyNode0;
            /mermaid
            </script>
          </div>
        </div>

        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Heapify Operation

            Heapify ensures a node satisfies the heap property.

            Steps:

            1. Compare node with children
            2. Swap with largest child
            3. Repeat recursively

            ####Height = log(n)####

            mermaid
            graph TD;
              Parent --> LeftChild;
              Parent --> RightChild;
              RightChild --> Swap;
              Swap --> Heapified;
            /mermaid
            </script>

          </div>
        </div>

        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Step 2 – Extract Maximum

            The largest element is always at the root.

            Steps:

            1. Swap root with last element
            2. Reduce heap size
            3. Heapify root

            ####Iterations = n - 1####

            mermaid
            graph TD;
              Root --> SwapLast;
              SwapLast --> ReduceHeap;
              ReduceHeap --> HeapifyRoot;
            /mermaid
            </script>
          </div>
        </div>

        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Example Execution

            Initial array:

            [4, 10, 3, 5, 1]

            After building heap:

            [10, 5, 3, 4, 1]

            After first extraction:

            [5, 4, 3, 1 | 10]

            ####Sorted grows from right####

            mermaid
            graph TD;
              Array --> BuildHeap;
              BuildHeap --> Extract1;
              Extract1 --> Sorted;
            /mermaid
            </script>

          </div>
        </div>

        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Time Complexity

            Heap Sort always runs in:

            - Best Case: ####O(n log n)####
            - Average Case: ####O(n log n)####
            - Worst Case: ####O(n log n)####

            Building heap:

            ####O(n)####

            Extraction:

            ####O(n log n)####

            mermaid
            graph TD;
              BuildHeap --> O_n;
              Extract --> O_nlogn;
              O_n --> Total;
              O_nlogn --> Total;
            /mermaid
            </script>

          </div>
        </div>

        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Space Complexity

            Heap Sort uses **constant extra memory**.

            Space complexity:

            ####O(1)####

            Characteristics:

            - In-place
            - No auxiliary arrays
            - Memory efficient

            mermaid
            graph TD;
              HeapSort --> InPlace;
              HeapSort --> ConstantMemory;
              InPlace --> Efficient;
              ConstantMemory --> Efficient;
            /mermaid
            </script>

          </div>
        </div>

        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Advantages and Disadvantages

            Advantages:

            - Guaranteed ####O(n log n)####
            - No extra memory
            - Predictable performance

            Disadvantages:

            - Not stable
            - Slower than QuickSort in practice
            - Poor cache performance

            mermaid
            graph TD;
              HeapSort --> Advantages;
              HeapSort --> Disadvantages;
              Advantages --> Fast;
              Disadvantages --> Slower;
            /mermaid
            </script>
          </div>
        </div>

        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Summary of Heap Sort

            Heap Sort process:

            1. Build Max Heap
            2. Swap root with last element
            3. Heapify root
            4. Repeat

            Key formulas:

            ####Left = 2i + 1####  
            ####Right = 2i + 2####  
            ####Time = O(n log n)####

            mermaid
            graph TD;
              Unsorted --> BuildHeap;
              BuildHeap --> Extract;
              Extract --> Sorted;
              Sorted --> End;
            /mermaid
            </script>
          </div>
        </div>

        <div class="slide active">
          <div class="slide-content markdown">
            <script type="text/markdown">
            # Exercise – Implement Heap Sort

            In this exercise you will implement the **Heap Sort algorithm**.

            Heap Sort works by:

            1. Building a **Max Heap**
            2. Repeatedly extracting the largest element
            3. Placing it at the end of the array

            Given a list of integers, your task is to **sort the list in ascending order** using Heap Sort.

            Example input:

            [4, 10, 3, 5, 1]

            Expected output:

            [1, 3, 4, 5, 10]

            Steps to follow:

            1. Write a function ####heapify(arr, n, i)####  
              - Ensure the subtree rooted at index ####i#### is a Max Heap

            2. Build the heap
              - Start at index ####floor(n/2) - 1####
              - Apply heapify moving toward the root

            3. Extract elements
              - Swap element ####0#### with ####n-1####
              - Reduce heap size
              - Heapify the root again

            Index formulas:

            ####LeftChild = 2i + 1####  
            ####RightChild = 2i + 2####

            mermaid
            graph TD;
              BuildHeap --> MaxHeap;
              MaxHeap --> ExtractMax;
              ExtractMax --> Heapify;
              Heapify --> SortedArray;
            /mermaid

            spoiler
            ```
            def heapify(arr, n, i):
                largest = i
                left = 2i + 1
                right = 2i + 2

                # Check left child
                if left < n and arr[left] > arr[largest]:
                    largest = left

                # Check right child
                if right < n and arr[right] > arr[largest]:
                    largest = right

                # Swap if needed
                if largest != i:
                    arr[i], arr[largest] = arr[largest], arr[i]

                    # Heapify the affected subtree
                    heapify(arr, n, largest)

            def heap_sort(arr):
                n = len(arr)

                # Build max heap
                for i in range(n//2 - 1, -1, -1):
                    heapify(arr, n, i)

                # Extract elements
                for i in range(n-1, 0, -1):

                    # Move root to end
                    arr[i], arr[0] = arr[0], arr[i]

                    # Heapify reduced heap
                    heapify(arr, i, 0)

            data = [4, 10, 3, 5, 1]
            heap_sort(data)
            print(data)
            ```
            /spoiler
            </script> 
          </div>
        </div>

        <!-- CONTROLS --> 
        <div class="nav-controls"> 
          <button class="btn btn-outline-dark me-2" id="prev">← Prev</button> 
          <button class="btn btn-outline-dark" id="next">Next →</button> 
        </div> 
        <div class="progress-container"> 
          <div class="progress-bar" id="progress"></div> 
        </div> 
        <div class="slide-counter"> 
          <span id="current">1</span>/<span id="total">1</span> 
        </div>
      </main>
    </div>
  </body>
  <script src="/javascripts/render-slides.js"></script>
</html>
